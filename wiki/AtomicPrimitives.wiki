#summary Atomic primitives available in PoCore
#labels Design

PoCore provides a few primitives for atomic operations. These are useful within (potentially) multi-threaded environments. Most applications will only be interested in the simplest primitives (increment and decrement), and using PoCore's higher level MutexPrimitives for all other situations.

The design goal is to provide the *useful* primitives, and the *sufficient* primitives for building further [http://en.wikipedia.org/wiki/Lock-free_and_wait-free_algorithms wait-free structures].

In particular, PoCore will use [http://en.wikipedia.org/wiki/Compare-and-swap Compare-and-Swap] as its foundation, and provide further functionality from there.

== API ==

I believe we need just three functions:

  # increment
  # decrement
  # compare-and-swap

The first two are the "useful" operations, while compare-and-swap is our building block for all atomic operations.

_TBD: I think we also want an init_once() like Subversion defines; this would be classified as "useful" rather than foundational_

== Comparison to APR ==

APR has defined an API around a number of atomic operations, and is useful as a comparison point for the design of PoCore's API. This section explains the differences, and rationale, from the APR model.

=== read32/set32 ===

These two functions are throwbacks to *very* old systems. Processors and compilers will _always_ read/write values as an atomic unit. Classically, it was possible for these operations to span clock cycles, fetching partial word-sizes in each cycle, and (thus) open to race conditions around interrupts modifying partial-words between those cycles. This is simply not a concern in today's systems, so these "operations" are not part of PoCore's API.

=== add32/sub32 ===

These functions can be implemented with code similar to:
{{{
  do {
    value = *mem;
    swapped = compare_and_swap(mem, value, value + delta);
  } while (!swapped);
}}}

Theoretically, the above loop will never complete where multiple writers are continuously modifying _mem_, but in all practical scenarios it succeeds on a single iteration.

=== inc32/dec32 ===

PoCore will provide these as "generally useful APIs", and they are effectively implemented as `add32(mem, 1)` and `sub32(mem, 1)`. In reality, they will be implemented in terms of compare-and-swap (see the loop above for add32/sub32), or possibly optimized for this specific functionality.

=== cas32/casptr ===

This is essentially the compare-and-swap functionality that PoCore will implement. However, the return value for PoCore will be an "is swapped" boolean, rather than the old value. In almost all cases, the old value is completely irrelevant (since it is subject to races), and the only interesting piece of information is "was my new value installed?"

=== xchg32/xchgptr ===

These functions are useless. Race conditions abound here... the "old value is returned" could be from a microsecond before or after an intended point of evaluation. It has no meaningful value whatsoever. From a concurrency standpoint, applications can simply use `read32()` to investigate a value and `set32()` to apply a new one (though, as previously-mentioned, those operations are similarly bogus in today's environments).
