#summary Basic design concepts for PoCore

==Context==

_TBD_

_see [http://pocore.googlecode.com/svn/trunk/include/pc_misc.h pc_misc.h]_

==Pools==

_TBD_

_see [http://pocore.googlecode.com/svn/trunk/include/pc_memory.h pc_memory.h]_

==Tracking==

_TBD_

_see [http://pocore.googlecode.com/svn/trunk/include/pc_track.h pc_track.h]_

==Error Handling==

Structured errors are returned by a number of PoCore functions. These errors are represented by `pc_error_t`. Each error must be recognized by the application and marked as handled by calling `pc_error_handled(error)`. Unhandled errors are stored in the PoCore context (`pc_context_t`). At termination, an application can use `pc_context_unhandled()` to fetch any errors that were not handled. It is important to note: unhandled errors represent *programmer errors*. An application should handle *all* errors returned by PoCore; at least, to ignore them and call `pc_error_handled`.

When `PC_DEBUG` is defined, `pc_context_destory(ctx)` will execute `abort()` if there are unhandled errors. You can then inspect the core dump and its queue of errors to determine where you may have missed handling an error return.

_see [http://pocore.googlecode.com/svn/trunk/include/pc_error.h pc_error.h]_

==Thread-Safety==

PoCore does not associate locks with any of its structures. This means the objects are *not* *re-entrant*. Thread-safety is left entirely to the application, which knows best about the use of PoCore's objects. PoCore does not contain any global variables -- everything is rooted from a `pc_context_t`.

Generally, an application should allocate one `pc_context_t` per thread, and ensure that (tracking) relationships are not established across context boundaries.

It is certainly possible to share PoCore objects among threads (provided appropriate management by the application). PoCore objects do not have thread-affinity.